import { usePinoramaClient } from "@/contexts"
import { buildPayload } from "@/modules/log-explorer/utils"
import { useInfiniteQuery, useQueryClient } from "@tanstack/react-query"

import type { SearchParams } from "@orama/orama"
import type { BaseOramaPinorama } from "pinorama-types"
import { useMemo } from "react"
import { fetchTotalCount } from "./use-total-logs"

export const useStaticLogs = <T extends BaseOramaPinorama>(
  term?: string,
  filters?: SearchParams<T>["where"],
  enabled?: boolean
) => {
  const client = usePinoramaClient()
  const queryClient = useQueryClient()

  const query = useInfiniteQuery({
    queryKey: ["static-logs", term, filters],
    queryFn: async ({ pageParam }) => {
      // await new Promise((resolve) => setTimeout(resolve, 300))
      // if (signal.aborted) return

      let cursor: number | undefined = undefined
      const totalCount = await fetchTotalCount(client, term, filters)

      const payload = buildPayload({
        term,
        filters,
        cursor
      })

      const response = await client?.search(payload)
      const newData = response?.hits.map((hit) => hit.document) ?? []

      const queryData = queryClient.getQueryData(["static-logs", term, filters])
      const fetchedCount =
        (queryData?.pages.reduce((acc, page) => acc + page.data.length, 0) ??
          0) + newData.length

      const hasNextCursor = fetchedCount < totalCount

      if (hasNextCursor) {
        const lastItem = newData[newData.length - 1]
        const metadata = lastItem._pinorama
        cursor = metadata.createdAt
      } else {
        cursor = undefined
      }

      return {
        data: newData,
        nextCursor: cursor
      }
    },
    initialPageParam: 0,
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    staleTime: 0,
    enabled
  })

  const flattenedData = useMemo(() => {
    return query.data?.pages.flatMap((page) => page.data) ?? []
  }, [query.data])

  return { ...query, data: flattenedData }
}
